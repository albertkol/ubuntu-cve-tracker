# Standard library
import os
import cve_lib
import requests
import re
import argparse
from http.cookiejar import MozillaCookieJar

# Local
from lib.file_helpers import JsonStore, download_gzip_file
from cvss import CVSS3
from macaroonbakery import httpbakery


def authentication(request, url, payload):
    """
    Authenticate with Macaroons in order to use Webteam API
    """

    client = httpbakery.Client(cookies=MozillaCookieJar(".login"))

    if os.path.exists(client.cookies.filename):
        client.cookies.load(ignore_discard=True)

    response = client.request(request, url=url, json=payload)
    client.cookies.save(ignore_discard=True)
    print(response.json())


parser = argparse.ArgumentParser(
    description="This file loads CVEs to webteam's db, using the endpoint ubuntu.com/security/cve"
)
parser.add_argument(
    "file_path",
    action="store",
    type=str,
    help="[Required] The path of the CVE file or folder",
)
parser.add_argument(
    "--slice",
    action="store",
    type=int,
    default=-101,
    help="[Optional] Number of CVEs to update, negative to start from bottom. Default 21",
)
args = parser.parse_args()

cve_data = None
download_gzip_file(
    url="http://archive.ubuntu.com/ubuntu/dists/bionic/main/source/Sources.gz",
    output_filename=".cache/main.txt",
    etag_store=JsonStore(".cache/etags.json"),
)
download_gzip_file(
    url="http://archive.ubuntu.com/ubuntu/dists/bionic/universe/source/Sources.gz",
    output_filename=".cache/universe.txt",
    etag_store=JsonStore(".cache/etags.json"),
)

PORT = 8001
url = f"http://localhost:{PORT}/security/"


def post_single_cve(cve_filename):
    # Upload active and ignored (in Ubuntu)
    cve_data = cve_lib.load_cve(cve_filename)

    references = cve_data["References"].split("\n")
    if references[0] == "":
        references.pop(0)

    cvss3 = None
    if len(cve_data["CVSS"]) > 0:
        if "3." in cve_data["CVSS"][0][1]:
            # Use CVSS3
            c = CVSS3(cve_data["CVSS"][0][1])
            cvss3 = c.scores()[0]

    packages = []
    for pkg in cve_data["pkgs"]:
        statuses = []
        for [key, value] in cve_data["pkgs"][pkg].items():
            codename_parts = key.split("/")
            codename = codename_parts[0]

            if codename == "devel":
                codename = "focal"

            if codename in cve_lib.releases + ["upstream"]:
                statuses.append(
                    {
                        "release_codename": codename,
                        "status": value[0],
                        "description": value[1],
                    }
                )
        package = {
            "name": pkg,
            "source": f"https://people.canonical.com/~ubuntu-security/cve/pkg/{key}.html",
            "ubuntu": f"https://packages.ubuntu.com/search?suite=all&section=all&arch=any&searchon=sourcenames&keywords={key}",
            "debian": f"https://tracker.debian.org/pkg/{key}",
            "statuses": statuses,
        }
        packages.append(package)

    status = "active"

    if "** REJECT **" in cve_data["Description"]:
        status = "rejected"

    notes = []

    for [author, note] in cve_data["Notes"]:
        notes.append({"author": author, "note": note})

    priority = cve_data["Priority"]

    if priority == "untriaged":
        priority = "unknown"

    cve = {
        "id": cve_data["Candidate"],
        "published": cve_data["PublicDate"],
        "description": cve_data["Description"],
        "ubuntu_description": cve_data["Ubuntu-Description"],
        "notes": notes,
        "priority": priority,
        "cvss3": cvss3,  # CVSS vector to convert into Base score
        "references": references,
        "bugs": cve_data["Bugs"].strip().split(),
        "packages": packages,
        "status": status,
    }

    return cve


if args:
    headers = {"Content-type": "application/json"}
    cve_filename = args.file_path

    if cve_filename == "../active" or cve_filename == "../ignored":
        list_cve_files = []
        cves = []
        # Note os.listdir gives unsorted list depending on filestystem
        for file in os.listdir(cve_filename):
            regex = re.compile("(cve-|CVE-)\\d{4}-\\d{4,7}")
            if re.match(regex, file):
                list_cve_files.append(file)

        # Use slice to get the number of CVEs to post
        # e.g. last 20, reverse order (latest first)
        list_cves = sorted(list_cve_files)
        for index in range(len(list_cves)):
            relative_path = f"{cve_filename}/{list_cves[index]}"
            cve = post_single_cve(relative_path)
            cves.append(cve)

        # Split into chunks of 300
        for chunk in [
            cves[i : i + 300] for i in range(0, len(cves), 300)  # noqa: E203
        ]:
            authentication("PUT", f"{url}cve", chunk)

    elif "not-for-us.txt" in cve_filename:
        # Upload not in Ubuntu
        # This has a bulk of CVEs, so we are just choosing 1 for now
        cve_id = cve_lib.parse_CVEs_from_uri(cve_filename)
        cve_list = []
        for index, cve in zip(range(300), cve_id):
            mitre = [f"https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve}"]
            note = [{
                "author": "ubuntu-security",
                "note": "Does not apply to software found in Ubuntu.",
            }]

            json = {
                "id": cve,
                "notes": note,
                "references": mitre,
                "status": "not-in-ubuntu"
            }
            cve_list.append(json)

        authentication("PUT", f"{url}cve", cve_list)

    else:
        cve = post_single_cve(cve_filename)
        authentication("POST", url + cve.id, cve)

else:
    print("CVE file not found")
